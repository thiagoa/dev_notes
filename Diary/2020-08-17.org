* PostgreSQL BRIN Indexes: Big Data Performance With Minimal Storage :postgres:readings:

Link: https://info.crunchydata.com/blog/postgresql-brin-indexes-big-data-performance-with-minimal-storage

- An index for searching time-series data
- Takes up much less (!!) space than B-tree

The article features comparisons between:

- Sequential scans
- Sequential scans with paralell workers
- B-tree
- BRIN

#+BEGIN_SRC sql
-- Unlogged tables do not generate WAL
CREATE UNLOGGED TABLE scans (
    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    scan float NOT NULL,
    created_at timestamptz NOT NULL
);

-- Insert 10.000.001 records
INSERT INTO scans (scan, created_at)
SELECT random(), x
FROM generate_series('2012-01-01 0:00'::timestamptz,
    '2018-05-03 20:33:20'::timestamptz, '2 seconds'::interval) x;

-- Sample query
SELECT date_trunc('day', created_at), avg(scan)
FROM scans
WHERE created_at BETWEEN '2017-02-01 0:00' AND '2017-02-28 11:59:59'
GROUP BY 1
ORDER BY 1;

-- Query without index (seq scan): 1595.763 ms
SET max_parallel_workers = 0;
EXPLAIN ANALYZE SELECT date_trunc('day', created_at), avg(scan)
FROM scans
WHERE created_at BETWEEN '2017-02-01 0:00' AND '2017-02-28 11:59:59'
GROUP BY 1
ORDER BY 1;

-- Query with parallel workers: 459.501 ms
SET max_parallel_workers = 8;
EXPLAIN ANALYZE SELECT date_trunc('day', created_at), avg(scan)
FROM scans
WHERE created_at BETWEEN '2017-02-01 0:00' AND '2017-02-28 11:59:59'
GROUP BY 1
ORDER BY 1;

-- With B-tree: 1137.303 ms, index size is 214 MB
--   w/ aggressive VACUUM settings
-- SELECT pg_size_pretty(pg_relation_size('scans_created_at_idx'));
CREATE INDEX scans_created_at_idx ON scans (created_at);
VACUUM FREEZE ANALYZE;
EXPLAIN ANALYZE SELECT date_trunc('day', created_at), avg(scan)
FROM scans
WHERE created_at BETWEEN '2017-02-01 0:00' AND '2017-02-28 11:59:59'
GROUP BY 1
ORDER BY 1;

-- With BRIN: 967.445 ms, index size is only 32 KB! (1/100th of the space)
-- SELECT pg_size_pretty(pg_relation_size('scans_created_at_brin_idx'));
CREATE INDEX scans_created_at_idx ON scans (created_at);
VACUUM FREEZE ANALYZE;
EXPLAIN ANALYZE SELECT date_trunc('day', created_at), avg(scan)
FROM scans
WHERE created_at BETWEEN '2017-02-01 0:00' AND '2017-02-28 11:59:59'
GROUP BY 1
ORDER BY 1;
#+END_SRC

The BRIN query is slower than the parallel query. Why? For this query
it might not make a big difference. For smaller datasets it might
outperform 20x faster than the parallel seq scan:

#+BEGIN_SRC sql
SELECT date_trunc('hour', created_at), avg(scan)
FROM scans
WHERE created_at BETWEEN '2017-02-14 0:00' AND '2017-02-14 11:59:59'
GROUP BY 1
ORDER BY 1;
#+END_SRC

* Avoiding the Pitfalls of BRIN Indexes in Postgres  :postgres:readings_todo:

Link: https://info.crunchydata.com/blog/avoiding-the-pitfalls-of-brin-indexes-in-postgres
