# Common Lisp notes

**TODO**: Organize me. I'm an old mess.

The best LISP is SBCL: Steel Bank Common Lisp.

- Read Practical Common Lisp.
- A vector in Common Lisp: `#(1 2 3)`. In Elisp this is different ([worth more investigation](https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequences-Arrays-Vectors.html)): `[1 2 3]`
- Common Lisp uses the [`#`](https://stackoverflow.com/questions/4873810/what-does-mean-in-lisp) syntax to define a multitude of types.
- Generalized variables: A generalized variable or place form is one of the many places in Lisp memory where values can be stored using the setf macro (see Setting Generalized Variables). The simplest place form is a regular Lisp variable.
- [Places](https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node80.html): Are setf'able with [Setf extensions](http://www.lispworks.com/documentation/lw71/CLHS/Body/m_defset.htm#defsetf).
- [Which Lisp dialect should you use for web programming?](https://www.quora.com/Which-Lisp-dialect-should-one-use-for-web-development)
- [Radiance web framework](https://github.com/Shirakumo/radiance-tutorial/blob/master/Part%201.md).
- [Yet another Common Lisp unit testing framework](https://github.com/fukamachi/prove): is it dead?
- `rplaca` to update `car`s.
- `symbol-value`: dynamically access the value of a variable. `set` to update it.
- Difference between `setq` and `setf`: Always use `setf`. It does everything `setq` does and supports places.
- `asdf` is Common Lisp's build system.
- `quicklisp` is Common Lisp's package downloader.
- [`cl-project`](https://github.com/fukamachi/cl-project) to create new common lisp projects.
- [https://lispcookbook.github.io/cl-cookbook/getting-started.html](Getting started with Common Lisp).
- `asdf:*central-registry*` holds a list of asdf's path. Link the project's .asd file from a project generated by `cl-project` in this folder, and run in the repl to compile the project:  `(asdf:operate 'asdf:load-op 'foo)` where `foo` is the name of the project. `(asdf:test-system :foo)` to run the tests.

- `defparameter` requires an initial value, `defvar` does not.
- defparameter variables are changed when code is reloaded with a new initial value, defvar variables are not.
- Use `eq` to compare symbols or conses by object id (using Ruby terms so that I can understand).
- Use `equal` to compare basic lisp data types
- Use `equalp` to compare strings with different capitalizations and integers to floating point numbers.
- Use `=` to compare numbers (`equal` and others also work)
- Use `string-equal` to compare strings (with different capitalizations as well).
- Rule of thumb: `eq` to compare symbols; `equal` for everything else, unless needs are very specific or forgiving.
- When dealing with alists, assoc + push are common functions.
- Functions can return multiple values with `(values v1 v2 v3 ...)`. There are functions to manipulate these values as well, to get them on the caller, like `multiple-value-bind`, etc.

https://lisp-lang.org/learn/lists

- #. evaluates forms at read-time and inserts them into the source code
- property lists: every symbol has them. `(symbol-plist 'x)`, `(setf (get 'x "value") 'men)`
- Vectors: `#(1 2 3)`, `(vector 1 2 3)`. A literal vector does not evaluate symbols, for example, `#(x x x)`. In Clojure, they do.
- Do not use literal values, nor lists, nor vectors, etc. if you are going to modify them. They are modified directly in the source code. Prefer the dynamic versions, like `vector` instead of `#()`.
- A repl can be written with `(defun repl () (loop (print (eval (read)))))`.

## Questions

- How to get help for a function in the REPL?
- What are the best sites to look up documentation?
- There's [Simplified Common Lisp Reference](http://jtra.cz/stuff/lisp/sclr/index.html)

Creating a keyword dynamically: (intern "KW" "KEYWORD")
